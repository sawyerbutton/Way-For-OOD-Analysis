# Way-For-OOD-Analysis

## 如何进行面向对象的分析

### 找出最关键的业务场景

> 通过业务中的动词描述进行寻找

1. 学生参加一门课的考试  ->  考试就是业务场景
2. 学生去图书馆借书 -> 借书就是业务场景
3. 学生去图书馆还书 -> 还书就是业务场景
4. 早晨去公司打卡 -> 打卡就是业务场景
5. 中午在公司刷卡吃饭 -> 吃饭就是业务场景

### 针对每个业务场景分析出场景的参与者

> 以对象形式参与业务场景的参与者

> 以服务形式参与业务场景的参与者

#### 之所以区分两者的原因是

1. 服务并不关心参与者是具体的某个对象`(换言之就是无状态)`,而只关心参与者是在系统中是何种服务
2. 对象则是关心参与者是某个具体的对象,也就是关心参与者是谁

### 分析每个场景内参与者的基本状态特征

> 基本状态特征是指对象与生俱来的一开始被创建出来之后就具有的状态特征

> 比如人的身高和体重就是人与生俱来的基本状态特征, 只要你是人你就一定会拥有这两个状态特征, 即使这两个状态特征会随着时间的推移发生数值的变化

> 再比如说这篇文字在撰写之时即拥有了内容这个基本状态特征, 只是内容这个基本状态特征可以在任何时间进行修改; 同样这篇文字也拥有创建时间这个基本状态特征,但是这个状态特征是无法修改的

> 值得注意的是某些与对象相关联的信息并不属于基本状态特征, 比如某开发人员参加了cisco资格认证考试并取得了资格证书, 那么该对象和证书之间存在了一对一的拥有关系, 这个证书也成为了该开发人员的状态特征, 但是这个状态特征并不是与生俱来的基本状态特征而是通过后天考试得来的产物所以它不是基本状态特征

### 分析每个场景参与者对象分别扮演的角色，整个场景的完整交互过程，对象在参与场景的过程中执行的交互行为

> 这个过程涉及到对象之间如何交互,涉及到如何分析特定对象的交互行为, 从而最终决定了在编码层次上具体类包含的具体行为

> 分析的重点在于将整个业务场景中的每个交互行为通过四色原型的分析方法来理解`一个什么样的人或组织或物品以某种角色在某个时刻或某段时间内参与某个活动`

> 同样也可以通过分析`交互行为是谁通知谁做什么事情`, 一般而言行为的驱动者就是通知方，行为的执行者就是被通知方，被通知方拥有`通知方要求做的事`的执行行为

> 需要注意区分的是现实生活中的对象并不是扮演了某个角色后才具有角色所定义的某种行为，而是固有存在的，只不过是在扮演角色后表现出了该行为, 因此对于现实生活中的对象，执行角色所定义的行为和扮演角色是同时发生的，没有谁先谁后的说法(正如学生之于学习和考试, 并没有谁先谁后的区分)

> 但是软件中的对象则不同，因为软件中的对象只是现实生活中的对象的某一方面, 它的作用是专而精而不是大而全

> 另外从设计实现的角度以职责单一的标准来看待软件中的对象时,也不会将软件中的对象设计的很复杂，包含多个职责，因为这样会导致对象难以维护，

> 给软件中的对象赋予多个角色或多个指责的方式虽不违背分析原则，但`违背设计原则`

> 软件中的对象往往是设计成`当它扮演某个角色时`，`动态给对象注入角色所定义的交互行为`，从而给对象`赋予了参与场景交互的能力`

> 简而言之,软件中的对象，`平时只具有基本的状态特征和基本的非交互行为`，而当它`扮演某个角色时`，则`动态具有交互行为`

### 分析如何记录和跟踪某次交互行为，分析该交互行为会产生哪些额外的信息

> 上述我们提到某开发人员通过参加cisco资格考试获得了某资格证书, 证书成为了其的状态特征但非基本状态特征的过程, 由此引入`一次对象的交互活动会产生一些与该交互活动相关的交互信息`

> 除了上述的例子外，很容易会联想到学生考试会获得考试成绩的状态信息, 员工吃饭会产生所选菜色和花费金额的状态信息, 市民借书产生的借阅信息

> 在某些情况下，这些状态信息可能会在之后被持续维护和更新，比如学生参加考试前考试得分是null但是参与之后会更新考试得分的状态信息,再比如市民借书所产生的还书时间这一状态信息随着时间的推移才会产生

> 从这些规律中可以发现`交互是一个过程`,并且该过程一旦开始后就会`产生一些相关的信息`，如考试的成绩，借阅信息的归还时间等

> 通常分析时会把交互过程本身所涉及的一切信息以及交互过程所产生的所有附加信息作为一个整体来进行考虑, 但是这样具有一个高耦合度

> 此时设计一个对象，用来表示某一次交互的结果，这个结果包含交互过程本身所涉及的一切信息以及交互过程所产生的所有附加信息会是一个更加合理的方案

> 在交互行为结束后设计一个对象用来`表示一次交互活动的相关信息`,这些信息一方面体现了`交互活动的参与者`(交互时间，交互地点)，另一方面体现了`交互活动所产生的附加的信息`

> 之所以将这些随着交互产生的信息定义为对象而不是值对象, 是因为这些信息并不是不可改变的内容, 相反这些信息更有可能在后续的交互过程中被更新